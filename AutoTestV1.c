#pragma config(Sensor, in1,    lineTrackFront, sensorLineFollower)
#pragma config(Sensor, in2,    lineTrackBack,  sensorLineFollower)
#pragma config(Sensor, dgtl1,  ultrasonicIN,   sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  button,         sensorTouch)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightWheel,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           middleWheel,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftWheel,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           turbine1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           turbine2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           turbine3,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           ballShootLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           ballShootRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rampAdjust,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define FULLPWR 127
#define HALFPWR 63
#define QTRPWR 32

//create functions up here

//begins ball shooting sequence NO TIMING NECESSARY
//Timing must be tested
void ballShoot()
{
  //go backward
  resetTimer(T1);
  while (time1[T1] < 375) //for 3/4 of half a second
  {
  	//turns turbines in the intake direction
		motor[turbine1] = -FULLPWR;
		motor[turbine2] = -FULLPWR; //the motor is already flipped on the bot
		motor[turbine3] = FULLPWR;
  }

  //use claw to flip
  resetTimer(T1);
  while (time1[T1] < 500) //for half a second
  {
  	//shoots balls
		motor[ballShootLeft] = FULLPWR;
  	motor[ballShootRight] = -FULLPWR;
  }
}



//begins cap flipping sequence when called NO TIMING NECESSARY
void capFlip()
{
	//go backward
  resetTimer(T1);
  while (time1[T1] < 375) //for 3/4 of half a second
  {
  	motor[leftWheel] = FULLPWR;
  	motor[rightWheel] = -FULLPWR;
  }

  //use claw to flip
  resetTimer(T1);
  while (time1[T1] < 500) //for half a second
  {
  	motor[claw] = -FULLPWR;
  }
}



void spinLeft()
{
	//spins left for half a second before coming to a stop
	motor[leftWheel] = -FULLPWR;
	motor[rightWheel] = FULLPWR;
	wait1Msec(500);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void spinRight()
{
	//spins right for half a second before coming to a stop
	motor[leftWheel] = FULLPWR;
	motor[rightWheel] = -FULLPWR;
	wait1Msec(500);

	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}



task main()
{
 int thresholdLine = 50; // light sensor threshold

 int capDist = 50; //ultrasonic range finder threshold
 int wallDist = 50;

 //straif to the right for 3/4 of half a second
 motor[middleWheel] = HALFPWR;
 wait1Msec(375);


 if (SensorValue[button] == 1) //straif to the left until the while loop is triggered
 {
 		motor[middleWheel] = HALFPWR;
}

 while(SensorValue[lineTrackFront] < thresholdLine || SensorValue[lineTrackBack] < thresholdLine) //when light
 {
   //set straif to 0 and go full power along the line
   motor[middleWheel] = 0;
 	motor[rightWheel]= FULLPWR;
 	motor[leftWheel]= FULLPWR;
 }

 //when the end of the line is reached or no line is sensed, go forward for half a second
 motor[rightWheel]= HALFPWR;
 motor[leftWheel]= HALFPWR;
 wait1Msec(500);

 //set all wheels to 0, stopping in front of the flags
 motor[rightWheel] = 0;
 motor[leftWheel] = 0;
 motor[middleWheel] = 0;

 //shoots the ball
 ballShoot();

 //go forward to align with the cap for half a second
 motor[rightWheel] = HALFPWR;
 motor[leftWheel] = HALFPWR;
 wait1Msec(500);

 //sense the cap with the ultrasonic range finder
 if (SensorValue[ultrasonicIN] > wallDist) //if the range finder senses the wall, spin left
 {
   spinLeft();
	}
	else if (SensorValue[ultrasonicIN] > capDist) //if the range finder senses the cap, spin right
	{
		spinRight();
	}


	//now that we are in position, flip the cap
	capFlip();





}
